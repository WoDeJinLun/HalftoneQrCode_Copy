//HQRC.h
#pragma once
/**
*	@brief Header files for the C++ utility library
*/
#include <stdlib.h>
/**
*	@brief Header files for the STL library
*/
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <cmath>
#include <list>
#include <limits>
#include <algorithm>
#include <functional>
#include <numeric>
#include <random>
#include <sstream>
//#include <strstream> UNLIN
#include <exception>
#include <math.h>
using namespace std;

/**
*	@brief Header files for the boost
*/
#include <boost/graph/adjacency_list.hpp>
/**
*	@brief Header files for OpenCV library 2.4.1
*/
/// Disable warnings generated by OpenCV
/// 'cv::XXXX' : function compiled as native
#pragma warning( disable:4793 )
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#define LIBFILE(x) x ".lib"
#define LIBdFILE(x) x "d.lib"
#include <opencv2/opencv.hpp>
#define OPENCV_VER 246
#define OPENCV_CORE "opencv_core" TOSTRING(OPENCV_VER)
#define OPENCV_IMGPROC "opencv_imgproc" TOSTRING(OPENCV_VER)
#define OPENCV_HIGHGUI "opencv_highgui" TOSTRING(OPENCV_VER)
#define OPENCV_VIDEO "opencv_video" TOSTRING(OPENCV_VER)
#define OPENCV_FEATURES2D "opencv_features2d" TOSTRING(OPENCV_VER)
#define OPENCV_OBJDETECT "opencv_objdetect" TOSTRING(OPENCV_VER)
#define OPENCV_ML "opencv_ml" TOSTRING(OPENCV_VER)
#define OPENCV_CALIB3D "opencv_calib3d" TOSTRING(OPENCV_VER)
#define OPENCV_CONTRIB "opencv_contrib" TOSTRING(OPENCV_VER)
#define OPENCV_LEGACY "opencv_legacy" TOSTRING(OPENCV_VER)
#define OPENCV_FLANN "opencv_flann" TOSTRING(OPENCV_VER)
#ifdef NDEBUG
#pragma comment( lib, LIBFILE(OPENCV_CORE))
#pragma message( "Link with " LIBFILE(OPENCV_CORE) )
#pragma comment( lib, LIBFILE(OPENCV_IMGPROC) )
#pragma message( "Link with " LIBFILE(OPENCV_IMGPROC) )
#pragma comment( lib, LIBFILE(OPENCV_HIGHGUI) )
#pragma message( "Link with " LIBFILE(OPENCV_HIGHGUI) )
#pragma comment( lib, LIBFILE(OPENCV_VIDEO) )
#pragma message( "Link with " LIBFILE(OPENCV_VIDEO) )
#pragma comment( lib, LIBFILE(OPENCV_FEATURES2D) )
#pragma message( "Link with " LIBFILE(OPENCV_FEATURES2D) )
#pragma comment( lib, LIBFILE(OPENCV_OBJDETECT) )
#pragma message( "Link with " LIBFILE(OPENCV_OBJDETECT) )
#else
#pragma comment( lib, LIBdFILE(OPENCV_CORE))
#pragma message( "Link with " LIBdFILE(OPENCV_CORE) )
#pragma comment( lib, LIBdFILE(OPENCV_IMGPROC) )
#pragma message( "Link with " LIBdFILE(OPENCV_IMGPROC) )
#pragma comment( lib, LIBdFILE(OPENCV_HIGHGUI) )
#pragma message( "Link with " LIBdFILE(OPENCV_HIGHGUI) )
#pragma comment( lib, LIBdFILE(OPENCV_VIDEO) )
#pragma message( "Link with " LIBdFILE(OPENCV_VIDEO) )
#pragma comment( lib, LIBdFILE(OPENCV_FEATURES2D) )
#pragma message( "Link with " LIBdFILE(OPENCV_FEATURES2D) )
#pragma comment( lib, LIBdFILE(OPENCV_OBJDETECT) )
#pragma message( "Link with " LIBdFILE(OPENCV_OBJDETECT) )
#endif

/**
*	@brief Header files for QR code generator Library
*/
#include "qrencode/Include/qrencode.h"
#include "qrencode/Include/qrspec.h"
#ifdef NOLIB
#elif NDEBUG
#pragma comment( lib, "qrencode.lib" )
#pragma message( "Link with QREncode.lib" )
#else
#pragma comment( lib, "qrencoded.lib" )
#pragma message( "Link with QREncoded.lib." )
#endif
/*
*	@brief Header files for GCoptimization library
*/
#include "GCO/GCoptimization.h"
#if NDEBUG
#pragma comment( lib, "GCoptimization.lib" )
#pragma message( "Link with GCoptimization.lib" )
#else
#pragma comment( lib, "GCoptimizationd.lib" )
#pragma message( "Link with GCoptimizationd.lib" )
#endif
#include "GCO/LinkedBlockList.h"
#ifdef NOLIB
#elif NDEBUG
#pragma comment( lib, "LinkedBlockList.lib" )
#pragma message( "Link with LinkedBlockList.lib" )
#else
#pragma comment( lib, "LinkedBlockListd.lib" )
#pragma message( "Link with LinkedBlockListd.lib" )
#endif
/**
*	@brief Header files for saed library
*/
#include "SAEDLIB/include/saed.h"
#if NDEBUG
#pragma comment( lib, "saed.lib" )
#pragma message( "Link with saed.lib." )
#else
#pragma comment( lib, "saed_D.lib" )
#pragma message( "Link with saed_D.lib." )
#endif
using namespace std;
using namespace cv;
#define M_PI_4     0.785398163397448309616
/// Convert System::String to std::string
/*
inline std::string MarshalString(System::String^ s)
{
using namespace System::Runtime::InteropServices;
const char* chars = (const char*)(Marshal::StringToHGlobalAnsi(s)).ToPointer();
std::string os(chars);
Marshal::FreeHGlobal(System::IntPtr((void*)chars));
return os;
}*/
template<class T>
void Free_VecPtr(vector<T>& _vec)
{
	typename vector<T>::iterator item_it;
	for (item_it = _vec.begin(); item_it != _vec.end(); ++item_it)
		delete (*item_it);
	_vec.clear();
}

namespace HQRCdata
{
	class		HKCModule;
}
namespace boost {

	enum vertex_element_t { vertex_element };
	BOOST_INSTALL_PROPERTY(vertex, element);
}

typedef vector<cv::Mat>		VecMat;
/// type define for boost graph edge property
typedef boost::property<boost::edge_weight_t, double> GEPropT;
/// type define for boost graph vertex property	
typedef boost::property<boost::vertex_element_t, HQRCdata::HKCModule*> GVPropT;
/// type define for boost graph
typedef boost::adjacency_list<boost::setS, boost::vecS, boost::undirectedS, GVPropT, GEPropT> GraphT;
/// type define for boost graph edge descriptor and iterators
typedef boost::graph_traits<GraphT>::edge_descriptor				GEDescT;
typedef boost::graph_traits<GraphT>::edge_iterator					GEIterT;
/// type define for boost graph vertex index map and data type
typedef boost::property_map<GraphT, boost::vertex_index_t>::type	GVIndexM;
/// type define for boost graph vertex descriptor and iterators
typedef boost::graph_traits<GraphT>::vertex_descriptor				GVDescT;
typedef boost::graph_traits<GraphT>::vertex_iterator				GVIterT;
/// type define for boost graph vertex element map and data type
typedef boost::property_map<GraphT, boost::vertex_element_t>::type	GVElemntM;
typedef boost::property_traits<GVElemntM>::value_type				GVElemntT;
/// type define for boost graph edge weight map and data type
typedef boost::property_map<GraphT, boost::edge_weight_t>::type		GEWeightM;
typedef boost::property_traits<GEWeightM>::value_type				GEWeightT;

namespace NFSSIM
{
	struct NFParam
	{
		int Channel;
		int Method;
		double K1;
		double K2;
		int L;
		int DownsampleWidth;
		int GaussKernel;
		double GaussSigma;

		NFParam(void) : Channel(0), Method(CV_BGR2YUV), K1(0.01), K2(0.03), L(255), DownsampleWidth(256), GaussKernel(11), GaussSigma(1.5) {}
	};

	double calcSSIM(cv::Mat& src1, cv::Mat& src2, cv::Mat& mask, cv::Mat& ssim_map, int channel = 0, int method = CV_BGR2YUV, const double K1 = 0.01, const double K2 = 0.03, const int L = 255, const int downsamplewidth = 256, const int gaussian_window = 11, const double gaussian_sigma = 1.5);
	double calcSSIMBB(cv::Mat& src1, cv::Mat& src2, cv::Mat& ssim_map, int channel = 0, int method = CV_BGR2YUV, int boundx = 0, int boundy = 0, const double K1 = 0.01, const double K2 = 0.03, const int L = 255, const int downsamplewidth = 256, const int gaussian_window = 11, const double gaussian_sigma = 1.5);

	double calcDSSIM(cv::Mat& src1, cv::Mat& src2, cv::Mat& mask, cv::Mat& ssim_map, int channel = 0, int method = CV_BGR2YUV, const double K1 = 0.01, const double K2 = 0.03, const int L = 255, const int downsamplewidth = 256, const int gaussian_window = 11, const double gaussian_sigma = 1.5);
	double calcDSSIMBB(cv::Mat& src1, cv::Mat& src2, cv::Mat& ssim_map, int channel = 0, int method = CV_BGR2YUV, int boundx = 0, int boundy = 0, const double K1 = 0.01, const double K2 = 0.03, const int L = 255, const int downsamplewidth = 256, const int gaussian_window = 11, const double gaussian_sigma = 1.5);

	/**
	*	@brief James: Some convenient overloaded functions
	*/
	double inline calcSSIM(cv::Mat& src1, cv::Mat& src2, NFParam& param, cv::Mat& mask, cv::Mat& ssim_map)
	{
		return calcSSIM(src1, src2, mask, ssim_map, param.Channel, param.Method, param.K1, param.K2, param.L, param.DownsampleWidth, param.GaussKernel, param.GaussSigma);
	}
	double inline calcSSIMBB(cv::Mat& src1, cv::Mat& src2, NFParam& param, cv::Mat& ssim_map, int boundx = 0, int boundy = 0)
	{
		return calcSSIMBB(src1, src2, ssim_map, param.Channel, param.Method, boundx, boundy, param.K1, param.K2, param.L, param.DownsampleWidth, param.GaussKernel, param.GaussSigma);
	}

	double inline calcDSSIM(cv::Mat& src1, cv::Mat& src2, NFParam& param, cv::Mat& mask, cv::Mat& ssim_map)
	{
		return calcDSSIM(src1, src2, mask, ssim_map, param.Channel, param.Method, param.K1, param.K2, param.L, param.DownsampleWidth, param.GaussKernel, param.GaussSigma);
	}
	double inline calcDSSIMBB(cv::Mat& src1, cv::Mat& src2, NFParam& param, cv::Mat& ssim_map, int boundx = 0, int boundy = 0)
	{
		return calcDSSIMBB(src1, src2, ssim_map, param.Channel, param.Method, boundx, boundy, param.K1, param.K2, param.L, param.DownsampleWidth, param.GaussKernel, param.GaussSigma);
	}
}
namespace Similarity
{
	/**
	*	@brief Base class for the pattern similarity interface
	*/
	class HKCPSFunc
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCPSFunc(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Similarity function						   */
		/*! \{                                                                 */

		/// Compute the similarity
		virtual double Compute(const cv::Mat&, const cv::Mat&) = 0;

		/// Normalize the similarity map
		virtual void Normalize(cv::Mat&, double, double) = 0;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */


		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCPSFunc(void) {}

		/*! \}                                                                 */
	};

	/**
	*	@brief Base class for the SSIM pattern similarity
	*          The larger the SSIM between two patterns is, the larger the similarity between them is
	*          This value is between 0 and 1, where 1 corresponds to perfect fit
	*/
	class HKCPSSSIM : public HKCPSFunc
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCPSSSIM(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCPSSSIM(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Similarity function						   */
		/*! \{                                                                 */

		/// Compute the similarity
		virtual double Compute(const cv::Mat& _m1, const cv::Mat& _m2)
		{
			cv::Mat m1 = _m1, m2 = _m2;
			NFSSIM::NFParam nfParam;
			nfParam.GaussKernel = 3;
			nfParam.GaussSigma = 0.0;
			cv::Mat mask = cv::Mat();
			cv::Mat ssim_map = cv::Mat();
			return NFSSIM::calcSSIM(m1, m2, nfParam, mask, ssim_map);
		}

		/// Normalize the similarity map
		/// Make sure that similar patterns have lower value
		/// The value of SSIM is between 0 and 1, where 1 corresponds to perfect fit
		virtual void Normalize(cv::Mat& _m, double _min, double _max)
		{
			cv::normalize(_m, _m, _min, _max, NORM_MINMAX);
			_m = cv::Scalar::all(_max) - _m;
		}

		/*! \}                                                                 */
	};

}
namespace HQRCdata
{
	//define
	class HKCModule;
	/// type define for the vector of QR code module
	typedef vector<HKCModule*> VecMdu;
	/*
	*	@brief Enumeration of QR code error correction level
	*/
	enum HKEECL
	{
		ECL_L = 0, ECL_M, ECL_Q, ECL_H
	};
	/**
	*	@brief Class for the importance map parameters
	*/

	class HKCImpParam
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCImpParam(void)
		{
			Min = 0.05;
			Max = 1.0;
			DilateIter = 3;
			SmoothKernel = 15;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCImpParam(void)
		{
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */

		double Min;
		double Max;
		int DilateIter;
		int SmoothKernel;

		void setImpParam(int level)
		{
			switch (level)
			{
			case 0:
				DilateIter = 0.5;
				break;
			case 1:
				DilateIter = 1.5;
				break;
			case 2:
				DilateIter = 2.5;
				break;


			}
		}
		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	private:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */
		/*! \}                                                                 */
	};
	/**
	*	@brief Class for the QR code parameters
	*/
	class HKCQRCParam
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCQRCParam(void)
		{
			m_Ver = 0;
			m_ECL = HKEECL::ECL_L;
		}
		HKCQRCParam(std::string text, int ver, HKEECL ECL)
		{
			m_Text = text;
			m_Ver = ver;
			m_ECL = ECL;
		}
		HKCQRCParam(std::string text)
		{
			m_Text = text;
			m_Ver = 5;
			m_ECL = HKEECL::ECL_H;
		}
		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCQRCParam(void)
		{
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */

		/*property System::String^ Text
		{
		System::String^ get(void) { return m_Text; }
		void set(System::String^ value)
		{
		if(System::String::Compare(m_Text, value) != 0)
		{
		m_Text = value;
		}
		}
		}

		property int Version
		{
		int get(void) { return m_Ver; }
		void set(int value)
		{
		if(m_Ver != value)
		m_Ver = value;
		}
		}

		property HKEECL ECLvl
		{
		HKEECL get(void) { return m_ECL; }
		void set(HKEECL value)
		{
		if(m_ECL != value)
		{
		m_ECL = value;
		}
		}
		}*/

		int RSNum;

		int ECCap;

		std::string ToString()
		{
			return "QR Code Parameters";
		}

		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		std::string		m_Text;		///< QR code text
		int				m_Ver;		///< QR code version
		HKEECL			m_ECL;		///< QR code error correction level		

		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the pattern database parameters
	*/
	class HKCPDBParam
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCPDBParam(void)
		{
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCPDBParam(void)
		{
		}


		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */

		/*property int PSize
		{
		int get(void) { return m_PSize; }
		void set(int value)
		{
		if(m_PSize != value)
		{
		m_PSize = value;
		}
		}
		}		*/
		std::string ToString()
		{
			return "Pattern Database Parameters";
		}

		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		int				m_PSize;	///< Pattern size		

		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the pattern assignment parameters
	*/
	class HKCOptmParam
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCOptmParam(void)
		{
			NScale = 100.0;
			WeightS = 0.2;
			WeightR = 0.0;
			SigmaS = 20;
			SigmaR = 10;
			SigmaM = 10;
			MaxECNum = -1;
			NormRel = false;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCOptmParam(void)
		{
		}



		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */

		double NScale;
		double WeightS;
		double WeightR;
		double SigmaS;
		double SigmaR;
		double SigmaM;
		int MaxECNum;
		bool NormRel;
		std::string ToString()
		{
			return "Pattern Assignment Parameters";
		}

		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	private:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */
		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the application parameters
	*/
	class HKCAppParam
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCAppParam(void)
		{
			mp_Imp = new HKCImpParam;
			mp_QRC = new HKCQRCParam;
			mp_PDB = new HKCPDBParam;
			mp_Optm = new HKCOptmParam;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Destructor                                */
		/*! \{                                                                 */

		virtual ~HKCAppParam(void)
		{
			delete mp_Imp;
			mp_Imp = nullptr;

			delete mp_QRC;
			mp_QRC = nullptr;

			delete mp_PDB;
			mp_PDB = nullptr;

			delete mp_Optm;
			mp_Optm = nullptr;

		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Design time properties                        */
		/*! \{                                                                 */

		HKCImpParam* ImpMap()
		{
			return mp_Imp;
		}

		HKCQRCParam* QRCode()
		{
			return mp_QRC;
		}

		HKCPDBParam* PDB()
		{
			return mp_PDB;
		}

		HKCOptmParam* Optimize()
		{
			return mp_Optm;
		}


		std::string ToString()
		{
			return "Application Parameters";
		}

		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	private:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{																   */
		HKCImpParam*	mp_Imp;
		HKCQRCParam*	mp_QRC;
		HKCPDBParam*	mp_PDB;
		HKCOptmParam*	mp_Optm;

		/*! \}                                                                 */
	};


	/**
	*	@brief Class for the image data
	*/
	class HKCImgData
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCImgData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCImgData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                    Initialization                            */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void)
		{
			isReady = false;
			SrcImg.release();
			RGBImg.release();
			Mask.release();
			HalftoneImg.release();
			EdgeMap.release();
			UserMap.release();
			ImpMap.release();
			SrcImgs.clear();
			RGBImgs.clear();
			Masks.clear();
			HalftoneImgs.clear();
			EdgeMaps.clear();
			UserMaps.clear();
			ImpMaps.clear();
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		bool	isReady;	///< Flag indicates if the data is ready
		cv::Mat SrcImg;     ///< Source image
		vector<cv::Mat>  SrcImgs; ///source imgaes;
		cv::Mat	RGBImg;		///< Source image in RGB color space
		vector<cv::Mat>  RGBImgs; ///< Source images in RGB color space
		cv::Mat RstImg;		///< Resutl image in RGB color space
		vector<cv::Mat>  RstImgs; ///< Resutl images in RGB color space
		cv::Mat	Mask;		///< Source image mask
		vector<cv::Mat> Masks;		///< Source image masks
		cv::Mat HalftoneImg;///< Halftone image	
		vector<cv::Mat> HalftoneImgs;///< Halftone image	
		cv::Mat EdgeMap;	///< Source edge map
		vector<cv::Mat> EdgeMaps;	///< Source edge maps
		cv::Mat UserMap;	///< Saliency map drown by user
		vector<cv::Mat> UserMaps;	///< Saliency maps drown by user
		cv::Mat ImpMap;		///< Importance map with type CV_64FC1 and has the same size of original QR code image)
		vector<cv::Mat> ImpMaps;		///< Importance maps with type CV_64FC1 and has the same size of original QR code image)
		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the QR code module
	*/
	class HKCModule
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCModule(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCModule(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void)
		{
			Type = -1;
			Pos = cv::Point(0, 0);
			QRC = -1;
			RSID = -1;
			CWID = -1;
			PID1 = -1;
			PID2 = -1;
			VID = -1;
			Weit = -1.0;
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		/// 0:Codewords
		/// 1:Remaining Bits
		/// 2:Version Information
		/// 3:Format Information 
		/// 4:Alignment Patterns
		/// 5:Timing Patterns
		/// 6:Separators and Position Detection Patterns
		int         Type;   ///< Type of module
		cv::Point   Pos;	///< Module's position		
		int         QRC;	///< QR code value (1: black, 0: white)
		int			RSID;	///< RS block ID (1-based index, -1 indicates non data module)
		int			CWID;	///< Codeword ID in the RS block (1-based index, -1 indicates non data module)	
		int			PID1;	///< Ideal/Original pattern ID
		int         PID2;   ///< Optimal pattern ID
		int   VID;	///< Vertex index in the graph
		double		Weit;	///< Importance of the module (0-1, -1 indicates non data module)

		/*! \}                                                                 */
	};



	/**
	*	@brief Class for the QR code code word
	*/
	class HKCCodeWord
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCCodeWord(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCCodeWord(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Functors                                 */
		/*! \{                                                                 */

		class Priority_GreatThan
		{
		public:
			bool operator()(HKCCodeWord* _lhs, HKCCodeWord* _rhs) { return _lhs->Priority > _rhs->Priority; }
		};

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void)
		{
			Tag = -1;
			RVal = 0.0;
			Weit = 0.0;
			Priority = 0;
			Modules.clear();
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		int		Tag;		///< -1: non-used codeword
		double	RVal;		///< Reliability		
		double	Weit;		///< Modules' averaged importance				
		double  Priority;	///< Priority of codeword
		VecMdu	Modules;	///< Modules (Store only pointers)

		/*! \}                                                                 */
	};

	/// type define for the vector of QR code code word
	typedef vector<HKCCodeWord*> VecCW;

	/**
	*	@brief Class for the QR code RS block
	*/
	class HKCRSBlock
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCRSBlock(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCRSBlock(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void)
		{
			Tag = -1;
			RVal = 0.0;
			Free_VecPtr(CodeWords);
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		int		Tag;		///< -1: non-used RS block
		double	RVal;		///< Reliability
		VecCW	CodeWords;	///< Code words

		/*! \}                                                                 */
	};

	/// type define for the vector of QR code code word
	typedef vector<HKCRSBlock*>	VecRSB;

	/**
	*	@brief Class for the QR code data
	*/
	class HKCQRCData
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCQRCData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCQRCData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void)
		{
			isReady = false;
			Text = "";
			Ver = -1;
			ECL = -1;
			ECC = -1;
			QRCode.release();
			QRCImg.release();
			RSMap.release();
			CWMap.release();
			Free_VecPtr(Modules);
			Free_VecPtr(RSBlocks);
			MdGraph.clear();
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		bool			isReady;	///< Flag indicates if the data is ready
		std::string		Text;		///< Encoded text string
		int				Ver;		///< QR code version (5, 10)
		int				ECL;		///< Error correction level
		int				ECC;		///< Error correction capacity		
		cv::Mat			QRCode;		///< Original QR code (8UC1)
		cv::Mat			QRCImg;		///< Upsample version QR code image (8UC1)
		cv::Mat			RSMap;		///< RS block map (CV_32SC1, 1-based index and value -1 indicates non-used pixel)
		cv::Mat			CWMap;		///< Code word map (CV_32SC1, 1-based index and value -1 indicates non-used pixel)		
		VecMdu			Modules;	///< QR code modules	
		vector<VecMdu>  VModules;
		VecRSB			RSBlocks;	///< QR code RS blocks
		vector<VecRSB>  VRSBlocks;
		GraphT			MdGraph;	///< Modules involve in the optimization (Store only pointers)
		vector<GraphT>  VMdGraph;
		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the image pattern
	*/
	class HKCPattern
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCPattern(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCPattern(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// Clear data
		void Clear(void)
		{
			ID = -1;
			Tag = -1;
			RVal = 0.0;
			RVal2 = 0.0;
			Img.release();
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		int		ID;		///< Pattern ID
		int		Tag;	///< Color of center pixel (1: black, 0: white)
		cv::Mat	Img;	///< Binary pattern image, white(255) and black(0)			
		double  RVal;	///< Reliability
		double	RVal2;	///< Original Reliability

		/*! \}                                                                 */
	};

	/// type define for the vector of image pattern
	typedef vector<HKCPattern*>	VecPtrn;

	/**
	*	@brief Class for the pattern database
	*/
	class HKCPDBData
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCPDBData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCPDBData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                      Methods                                 */
		/*! \{                                                                 */


		/// Clear data
		void Clear(void)
		{
			isReady = false;
			PSize = -1;
			Free_VecPtr(Patterns);
			Whites.clear();
			Blacks.clear();
			SimMap.release();
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		bool			isReady;	///< Flag indicates if the data is ready				
		int				PSize;		///< Pattern size (3X3)				
		VecPtrn			Patterns;	///< Image patterns	
		VecPtrn			Whites;		///< Patterns whose center pixel are white(0)
		VecPtrn			Blacks;		///< Patterns whose center pixel are black(1)
		cv::Mat			SimMap;		///< Similarity map

		/*! \}																	*/
	};

	/**
	*	@brief Class for the application data
	*/
	class HKCAppData
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                    Constructors                              */
		/*! \{                                                                 */

		HKCAppData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCAppData(void) { Clear(); }

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                      Methods                                 */
		/*! \{                                                                 */

		/// clear data
		void Clear(void)
		{
			ImgData.Clear();
			QRCData.Clear();
			PDBData.Clear();
		}

		/*! \}                                                                 */
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		HKCImgData	ImgData;
		HKCQRCData	QRCData;
		HKCPDBData	PDBData;

		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the application item
	*/
	class HKCAppItem
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCAppItem(void)
		{
			mp_param = new HKCAppParam;
			mp_Data = new HKCAppData;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		~HKCAppItem(void)
		{
			mp_param = nullptr;
			mp_Data = NULL;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                   Item Operations                            */
		/*! \{                                                                 */

		HKCAppData* Data()
		{
			return mp_Data;
		}
		HKCAppParam* Param()
		{
			return mp_param;
		}
		void setrgbimg(cv::Mat rgbimg)
		{
			mp_Data->ImgData.RGBImg = rgbimg;
		}
		void setusermap(cv::Mat usermap)
		{
			mp_Data->ImgData.UserMap = usermap;
		}
		void setsrcimg(cv::Mat srcimg)
		{
			mp_Data->ImgData.SrcImg = srcimg;
		}



		/*! \}                                                                 */
		/*==========================  PRIVATE  ================================*/
	private:
		/*---------------------------------------------------------------------*/
		/*! \name                        Data								   */
		/*! \{                                                                 */

		HKCAppData*				mp_Data;		///< Application data		
		HKCAppParam*			mp_param;
		/*! \}                                                                 */
	};
}
namespace energy
{
	/// Similarity energy	
	class SimEnrgyNoPenalty
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		inline double operator()(HQRCdata::HKCModule*	_m, HQRCdata::HKCPattern*	_p, cv::Mat& _simMap, HQRCdata::HKCOptmParam* _param)
		{
			//return _m->Weit*_simMap.at<double>(_p->ID, _m->PID1);			
			return _simMap.at<double>(_p->ID, _m->PID1);
		}

		/*! \}                                                                 */
	};

	/// Similarity energy: Penalize similarity term if module->QRC != pattern->Tag
	class SimEnrgyWithPenalty
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		inline double operator()(HQRCdata::HKCModule*	_m, HQRCdata::HKCPattern*	_p, cv::Mat& _simMap, HQRCdata::HKCOptmParam* _param)
		{
			/*double sVal = (_m->QRC == _p->Tag) ? _simMap.at<double>(_p->ID, _m->PID1) : 1.0;
			return _m->Weit*sVal;*/

			//return (_m->QRC == _p->Tag) ? _m->Weit*_simMap.at<double>(_p->ID, _m->PID1) : 10.0;
			return (_m->QRC == _p->Tag) ? _simMap.at<double>(_p->ID, _m->PID1) : 1.0;
		}

		/*! \}                                                                 */
	};

	/// Reliability energy: Compute linear reliability energy
	class RelEnrgyLinear
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		inline double operator()(HQRCdata::HKCModule*	_m, HQRCdata::HKCPattern*	_p, HQRCdata::HKCOptmParam* _param)
		{
			double rVal = (_m->QRC == _p->Tag) ? fabs(1.0 - _p->RVal) : 1.0;

			//return Math::Sqrt(_param->WeightR*(1.0-_m->Weit))*rVal;
			//return _param->WeightR*fabs(1.0-_m->Weit)*rVal;
			return _param->WeightR*exp(_m->Weit*-_param->SigmaM)*rVal;
		}

		/*! \}                                                                 */
	};

	/// Reliability energy: Compute exponential reliability energy	
	class RelEnrgyExp
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		inline double operator()(HQRCdata::HKCModule*	_m, HQRCdata::HKCPattern*	_p, HQRCdata::HKCOptmParam* _param)
		{
			double rVal = (_m->QRC == _p->Tag) ? exp(_p->RVal*-_param->SigmaR) : 1.0;

			//return Math::Sqrt(_param->WeightR*(1.0-_m->Weit))*rVal;			
			//return _param->WeightR*fabs(1.0-_m->Weit)*rVal;
			return _param->WeightR*exp(_m->Weit*-_param->SigmaM)*rVal;
		}

		/*! \}                                                                 */
	};

	/// Compute the total energy function
	class EnergyFunc
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		EnergyFunc(HQRCdata::VecPtrn& _patterns, cv::Mat&	_simMap, GraphT& _graph)
			: m_SimEnrgy(), m_RelEnrgy(), m_Patterns(_patterns), m_SimMap(_simMap), m_Graph(_graph)
		{
			m_VelmtMap = boost::get(boost::vertex_element, m_Graph);
			m_EWeitMap = boost::get(boost::edge_weight, m_Graph);
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name				    Computation		                           */
		/*! \{                                                                 */

		/// DataCost		
		inline double DataCost(int _m, int _l, HQRCdata::HKCOptmParam* _param)
		{
			HQRCdata::HKCModule* m_pt = m_VelmtMap[_m];
			HQRCdata::HKCPattern* p_pt = m_Patterns[_l];

			double simVal = m_SimEnrgy(m_pt, p_pt, m_SimMap, _param);
			double relVal = m_RelEnrgy(m_pt, p_pt, _param);
			return (simVal + relVal);
		}

		inline double DataCostNoPenalty(int _m, int _l, HQRCdata::HKCOptmParam* _param)
		{
			HQRCdata::HKCModule* m_pt = m_VelmtMap[_m];
			HQRCdata::HKCPattern* p_pt = m_Patterns[_l];

			SimEnrgyNoPenalty simEnrgy;
			double simVal = simEnrgy(m_pt, p_pt, m_SimMap, _param);
			double relVal = m_RelEnrgy(m_pt, p_pt, _param);
			return (simVal + relVal);
		}

		inline double EdgeWeight(GEDescT _e, HQRCdata::HKCOptmParam* _param)
		{
			return _param->WeightS*m_EWeitMap[_e];
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
		/*---------------------------------------------------------------------*/
		/*! \name						Data		                           */
		/*! \{                                                                 */

		HQRCdata::VecPtrn&		m_Patterns;
		cv::Mat&		m_SimMap;
		GraphT&			m_Graph;
		GVElemntM		m_VelmtMap;
		GEWeightM		m_EWeitMap;
		SimEnrgyWithPenalty	m_SimEnrgy;
		RelEnrgyLinear		m_RelEnrgy;

		/*! \}                                                                 */
	};
}
namespace HKCV
{
	void Mat_Decompose(const cv::Mat&, cv::Mat&, cv::Mat&);
	void Brightness_Contrast(const cv::Mat&, cv::Mat&, double, double);
	void Brightness_Contrast(const vector<cv::Mat>&, vector<cv::Mat>&, double, double);
	void Brightness_Contrast(const cv::Mat&, cv::Mat&, int);
	void Unsharp_Mask(const cv::Mat&, cv::Mat&, double, double, double, cv::Mat&);
	void Unsharp_Mask(const vector<cv::Mat>&, vector<cv::Mat>&, double, double, double, vector<cv::Mat>&);
	void Unsharp_Mask(const cv::Mat&, cv::Mat&, int, cv::Mat&);
}
namespace HQRCALGORITHM
{
	/**
	*	@brief Base class for the algorithm interface
	*/
	class HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCAlgorithm(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Execute the algorithm
		virtual bool Execute(HQRCdata::HKCAppItem*) = 0;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		/*virtual property System::String^ Abbrev
		{
		System::String^ get(void) { return "Algo"; }
		}*/
		std::string ToString()
		{
			return "Application Algorithm";
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCAlgorithm(void) {}

		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the default data initialization
	*/
	class HKCDataInit1 : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCDataInit1(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCDataInit1(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Data initialization
		virtual bool Execute(HQRCdata::HKCAppItem*) override;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		/*virtual property System::String^ Abbrev
		{
		System::String^ get(void) override { return "DataInit1"; }
		}*/
		std::string ToString()
		{
			return "Default Data Initialization";
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:

	};
	/**
	*	@brief Class for the pattern database process
	*/
	class HKCPDBProc1 : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCPDBProc1(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCPDBProc1(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Pre-compute data from database
		virtual bool Execute(HQRCdata::HKCAppItem*) override;

		//static 

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		/*virtual property System::String^ Abbrev
		{
		System::String^ get(void) override { return "PDBProc1"; }
		}*/
		std::string ToString()
		{
			return "Pattern Database Process";
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:

	};
	/**
	*	@brief Class for the default QR code generator
	*/
	class HKCQRCGen1 : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCQRCGen1(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCQRCGen1(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Generate QR code
		virtual bool Execute(HQRCdata::HKCAppItem*) override;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		/*virtual property System::String^ Abbrev
		{
		System::String^ get(void) override { return "QRCGen1"; }
		}*/
		std::string ToString()
		{
			return "Default QR code generator";
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:

	};
	/**
	*	@brief Class for the canny edge feature map
	*/
	class HKCCannyFetr : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCCannyFetr(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCCannyFetr(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Generate Canny edge feature map
		virtual bool Execute(HQRCdata::HKCAppItem*) override;

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
	};
	/**
	*	@brief Class for the feature-based importance map
	*/
	class HKCFetrImp : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCFetrImp(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCFetrImp(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Generate feature-based importance map
		virtual bool Execute(HQRCdata::HKCAppItem*) override;

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
	};
	/**
	*	@brief Class for the halftoning method using structure-aware error diffusion
	*/
	class HKCSAEDHftn : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCSAEDHftn(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCSAEDHftn(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Perform structure-aware error diffusion image halftoning
		virtual bool Execute(HQRCdata::HKCAppItem*) override;

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
	};
	/**
	*	@brief Class for the base optimization interface
	*/
	class HKCOptimizer : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCOptimizer(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Perform pattern assignment optimization
		virtual bool Execute(HQRCdata::HKCAppItem* _appItem) override
		{
			if (!Initialize(_appItem))
			{
				cout << "HKCOptimizer::Execute() : Initialization failed" << endl;
				return false;
			}

			if (!Optimize(_appItem))
			{
				cout << "HKCOptimizer::Execute() : Optimization failed" << endl;
				return false;
			}

			/// Analyze the optimized result
			Analyze(_appItem);

			return true;
		}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		/*virtual property System::String^ Abbrev
		{
		System::String^ get(void) override { return "Optimizer"; }
		}*/
		std::string ToString()
		{
			return "Base Optimization Interface";
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCOptimizer(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                Internal Operations						   */
		/*! \{                                                                 */

		/// Initialize data used for optimization
		virtual bool Initialize(HQRCdata::HKCAppItem*);

		/// Perform pattern assignment optimization using specific approach
		virtual bool Optimize(HQRCdata::HKCAppItem*) = 0;

		/// Analyze the optimized result
		virtual void Analyze(HQRCdata::HKCAppItem*);

		/*! \}                                                                 */
	};

	/**
	*	@brief Class for the nearest-neighbors approach.
	This approach find the most similar pattern with the same value as the original QR code at the center pixel.
	*/
	class HKCNNOptmzr : public HKCOptimizer
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCNNOptmzr(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCNNOptmzr(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		/*virtual property System::String^ Abbrev
		{
		System::String* get(void) override { return "NN1"; }
		}*/
		std::string ToString()
		{
			return "Nearest-Neighbors Approach 1";
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
		/*---------------------------------------------------------------------*/
		/*! \name                Internal Operations						   */
		/*! \{                                                                 */

		/// Perform the optimization
		virtual bool Optimize(HQRCdata::HKCAppItem*) override;

		/*! \}                                                                 */
	};
	/**
	*	@brief Class for the unconstrained Graph-Cuts.
	*/
	class HKCUGCOptmzr : public HKCOptimizer
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCUGCOptmzr(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCUGCOptmzr(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                  Access Methods                              */
		/*! \{                                                                 */

		/*virtual property System::String* Abbrev
		{
		System::String* get(void) override { return "UGC"; }
		}*/
		std::string ToString()
		{
			return "Unconstrained Graph-Cuts";
		}

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
		/*---------------------------------------------------------------------*/
		/*! \name                Internal Operations						   */
		/*! \{                                                                 */

		/// Perform the optimization
		virtual bool Optimize(HQRCdata::HKCAppItem*) override;

		/*! \}                                                                 */
	};

	class HKCDefComposr : public HKCAlgorithm
	{
		/*==========================  PUBLIC  =================================*/
	public:
		/*---------------------------------------------------------------------*/
		/*! \name                   Constructors                               */
		/*! \{                                                                 */

		HKCDefComposr(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                     Destructor                               */
		/*! \{                                                                 */

		virtual ~HKCDefComposr(void) {}

		/*! \}                                                                 */
		/*---------------------------------------------------------------------*/
		/*! \name                 Algorithm Operations						   */
		/*! \{                                                                 */

		/// Perform image composition
		virtual bool Execute(HQRCdata::HKCAppItem*) override;

		/*! \}                                                                 */
		/*=========================  PROTECTED  ===============================*/
	protected:
	};

}
namespace HQRCode
{
	class HQRC
	{
	public:

		HQRC(cv::Mat srcImg, cv::Mat usermap, cv::Mat mask, HQRCdata::HKCQRCParam* qrcparam, cv::Mat& ORIQRC, cv::Mat& Halftone, cv::Mat& dstimg)
		{
			appitem = NULL;
			appitem = new HQRCdata::HKCAppItem;
			HQRCdata::HKCImgData& imagedata = appitem->Data()->ImgData;
			HQRCdata::HKCQRCData& qrcdata = appitem->Data()->QRCData;
			imagedata.SrcImg = srcImg;   // Read the file
			imagedata.UserMap = usermap; // Read the file
			imagedata.Mask = mask;
			HQRCdata::HKCQRCParam* QRCparam = appitem->Param()->QRCode();
			QRCparam->m_Text = qrcparam->m_Text;
			QRCparam->m_Ver = qrcparam->m_Ver;
			QRCparam->m_ECL = qrcparam->m_ECL;

			vector<HQRCALGORITHM::HKCAlgorithm*>* algoObjs = new vector<HQRCALGORITHM::HKCAlgorithm*>;
			if (!appitem->Data()->PDBData.isReady)
				algoObjs->push_back(new HQRCALGORITHM::HKCPDBProc1);

			algoObjs->push_back(new HQRCALGORITHM::HKCQRCGen1);

			algoObjs->push_back(new HQRCALGORITHM::HKCDataInit1);

			algoObjs->push_back(new HQRCALGORITHM::HKCCannyFetr);

			algoObjs->push_back(new HQRCALGORITHM::HKCFetrImp);

			algoObjs->push_back(new HQRCALGORITHM::HKCSAEDHftn);

			//algoObjs->Add(new HQRCALGORITHM::HKCUGCOptmzr);
			algoObjs->push_back(new HQRCALGORITHM::HKCNNOptmzr);

			//algoObjs->push_back(new HQRCALGORITHM::HKCDefComposr);

			for (int i = 0; i <algoObjs->size();)
			{
				cout << i << " " << algoObjs->size() << endl;
				//cout<<MarshalString(algoObj->ToString())<<endl;
				if (!algoObjs->front()->Execute(appitem))
				{
					cout << "failed!" << endl;;
					break;
				}

				algoObjs->erase(algoObjs->begin());
			}
			dstimg = imagedata.RstImg;
			Halftone = imagedata.HalftoneImg;
			ORIQRC = qrcdata.QRCImg;
			cout << "finish!" << endl;

		}

		HQRC(cv::Mat srcImg, cv::Mat usermap, HQRCdata::HKCQRCParam* qrcparam, cv::Mat& ORIQRC, cv::Mat& Halftone, cv::Mat& dstimg)
		{
			appitem = NULL;
			appitem = new HQRCdata::HKCAppItem;
			HQRCdata::HKCImgData& imagedata = appitem->Data()->ImgData;
			HQRCdata::HKCQRCData& qrcdata = appitem->Data()->QRCData;
			imagedata.SrcImg = srcImg;   // Read the file
			imagedata.UserMap = usermap; // Read the file
			HQRCdata::HKCQRCParam* QRCparam = appitem->Param()->QRCode();
			QRCparam->m_Text = qrcparam->m_Text;
			QRCparam->m_Ver = qrcparam->m_Ver;
			QRCparam->m_ECL = qrcparam->m_ECL;

			vector<HQRCALGORITHM::HKCAlgorithm*>* algoObjs = new vector<HQRCALGORITHM::HKCAlgorithm*>;
			if (!appitem->Data()->PDBData.isReady)
				algoObjs->push_back(new HQRCALGORITHM::HKCPDBProc1);

			algoObjs->push_back(new HQRCALGORITHM::HKCQRCGen1);

			algoObjs->push_back(new HQRCALGORITHM::HKCDataInit1);

			algoObjs->push_back(new HQRCALGORITHM::HKCCannyFetr);

			algoObjs->push_back(new HQRCALGORITHM::HKCFetrImp);

			algoObjs->push_back(new HQRCALGORITHM::HKCSAEDHftn);

			//algoObjs->Add(new HQRCALGORITHM::HKCUGCOptmzr);
			algoObjs->push_back(new HQRCALGORITHM::HKCNNOptmzr);

			//algoObjs->push_back(new HQRCALGORITHM::HKCDefComposr);

			for (int i = 0; i <algoObjs->size();)
			{
				cout << i << " " << algoObjs->size() << endl;
				//cout<<MarshalString(algoObj->ToString())<<endl;
				if (!algoObjs->front()->Execute(appitem))
				{
					cout << "failed!" << endl;
					break;
				}
				algoObjs->erase(algoObjs->begin());
			}

			dstimg = imagedata.RstImg;
			Halftone = imagedata.HalftoneImg;
			ORIQRC = qrcdata.QRCImg;
			cout << "finish!" << endl;
		}
	public:
		virtual ~HQRC(void){}

	private:

		HQRCdata::HKCAppItem* appitem;

	};
	class CHQRC
	{
	public:

		CHQRC(cv::Mat srcImg, cv::Mat usermap, cv::Mat mask, HQRCdata::HKCQRCParam* qrcparam, cv::Mat& ORIQRC, cv::Mat& Halftone, cv::Mat& dstimg)
		{
			bool fail = false;
			cv::Mat srcBkp;
			VecMat srcCnls, rstCnls;
			appitem = new HQRCdata::HKCAppItem;
			HQRCdata::HKCImgData& imagedata = appitem->Data()->ImgData;
			HQRCdata::HKCQRCData& qrcdata = appitem->Data()->QRCData;
			imagedata.SrcImg = srcImg;   // Read the file
			imagedata.UserMap = usermap; // Read the file
			imagedata.Mask = mask;
			HQRCdata::HKCQRCParam* QRCparam = appitem->Param()->QRCode();
			QRCparam->m_Text = qrcparam->m_Text;
			QRCparam->m_Ver = qrcparam->m_Ver;
			QRCparam->m_ECL = qrcparam->m_ECL;

			vector<HQRCALGORITHM::HKCAlgorithm*>* algoObjs = new vector<HQRCALGORITHM::HKCAlgorithm*>;
			if (!appitem->Data()->PDBData.isReady)
				algoObjs->push_back(new HQRCALGORITHM::HKCPDBProc1);

			algoObjs->push_back(new HQRCALGORITHM::HKCQRCGen1);

			algoObjs->push_back(new HQRCALGORITHM::HKCDataInit1);

			algoObjs->push_back(new HQRCALGORITHM::HKCCannyFetr);

			algoObjs->push_back(new HQRCALGORITHM::HKCFetrImp);

			/// Go through each object and execute the algorithm
			for (int i = 0; i <algoObjs->size();)
			{
				cout << i << " " << algoObjs->size() << endl;
				//cout<<MarshalString(algoObj->ToString())<<endl;
				if (!algoObjs->front()->Execute(appitem))
				{
					cout << "failed!" << endl;
					break;
				}
				algoObjs->erase(algoObjs->begin());
			}

			if (!fail){
				cv::Mat srcBkp;
				VecMat srcCnls, rstCnls;
				/// Color image
				srcBkp = imagedata.RGBImg.clone();
				cv::split(srcBkp, srcCnls);

				algoObjs->clear();

				algoObjs->push_back(new HQRCALGORITHM::HKCSAEDHftn);

				algoObjs->push_back(new HQRCALGORITHM::HKCNNOptmzr);
				//algoObjs->push_back(new HQRCALGORITHM::HKCNNOptmzr);

				//algoObjs->push_back(new HQRCALGORITHM::HKCDefComposr);

				for (int i = 0; i < 3; ++i)
				{
					/// Apply the algorithm to each channel		
					imagedata.RGBImg = srcCnls[i];

					/// Go through each object and execute the algorithm
					for (int j = 0; j <algoObjs->size(); j++)
					{
						cout << j << " " << algoObjs->size() << endl;
						//cout<<MarshalString(algoObj->ToString())<<endl;
						if (!(*algoObjs)[j]->Execute(appitem))
						{
							cout << "failed!" << endl;
							break;
						}
					}
					rstCnls.push_back(imagedata.RstImg);
				}
				if (!fail)
				{
					cv::merge(rstCnls, imagedata.RstImg);
					imagedata.RGBImg = srcBkp;
					srcCnls.clear();

					dstimg = imagedata.RstImg;
					Halftone = imagedata.HalftoneImg;
					ORIQRC = qrcdata.QRCImg;
					cout << "finish!" << endl;
				}
			}
		}

		CHQRC(cv::Mat srcImg, cv::Mat usermap, HQRCdata::HKCQRCParam* qrcparam, cv::Mat& ORIQRC, cv::Mat& Halftone, cv::Mat& dstimg)
		{
			bool fail = false;
			cv::Mat srcBkp;			
			appitem = new HQRCdata::HKCAppItem;
			HQRCdata::HKCImgData& imagedata = appitem->Data()->ImgData;
			HQRCdata::HKCQRCData& qrcdata = appitem->Data()->QRCData;
			imagedata.SrcImg = srcImg;   // Read the file
			imagedata.UserMap = usermap; // Read the file
			HQRCdata::HKCQRCParam* QRCparam = appitem->Param()->QRCode();
			QRCparam->m_Text = qrcparam->m_Text;
			QRCparam->m_Ver = qrcparam->m_Ver;
			QRCparam->m_ECL = qrcparam->m_ECL;

			vector<HQRCALGORITHM::HKCAlgorithm*>* algoObjs = new vector<HQRCALGORITHM::HKCAlgorithm*>;
			if (!appitem->Data()->PDBData.isReady)
				algoObjs->push_back(new HQRCALGORITHM::HKCPDBProc1);

			algoObjs->push_back(new HQRCALGORITHM::HKCQRCGen1);

			algoObjs->push_back(new HQRCALGORITHM::HKCDataInit1);

			algoObjs->push_back(new HQRCALGORITHM::HKCCannyFetr);

			algoObjs->push_back(new HQRCALGORITHM::HKCFetrImp);

			/// Go through each object and execute the algorithm
			for (int i = 0; i <algoObjs->size();)
			{
				cout << i << " " << algoObjs->size() << endl;
				//cout<<MarshalString(algoObj->ToString())<<endl;
				if (!algoObjs->front()->Execute(appitem))
				{
					cout << "failed!" << endl;
					break;
				}
				algoObjs->erase(algoObjs->begin());
			}

			if (!fail)
			{
				/// Color image
				srcBkp = imagedata.RGBImg.clone();
				cv::split(srcBkp, srcCnls);

				algoObjs->clear();

				algoObjs->push_back(new HQRCALGORITHM::HKCSAEDHftn);

				algoObjs->push_back(new HQRCALGORITHM::HKCNNOptmzr);
				//algoObjs->push_back(new HQRCALGORITHM::HKCNNOptmzr);

				//	algoObjs->push_back(new HQRCALGORITHM::HKCDefComposr);

				for (int i = 0; i < 3; ++i)
				{
					/// Apply the algorithm to each channel		
					imagedata.RGBImg = srcCnls[i];

					/// Go through each object and execute the algorithm
					for (int j = 0; j <algoObjs->size(); j++)
					{
						cout << j << " " << algoObjs->size() << endl;
						//cout<<MarshalString(algoObj->ToString())<<endl;
						if (!(*algoObjs)[j]->Execute(appitem))
						{
							cout << "failed!" << endl;
							break;
						}
					}

					rstCnls.push_back(imagedata.RstImg.clone());
				}
				if (!fail)
				{
					cv::merge(rstCnls, imagedata.RstImg);
					imagedata.RGBImg = srcBkp;
					rstCnls.clear();
					srcCnls.clear();


					dstimg = imagedata.RstImg;
					Halftone = imagedata.HalftoneImg;
					ORIQRC = qrcdata.QRCImg;
					cout << "finish!" << endl;
				}
			}
		}


	public:
		virtual ~CHQRC(void){}

	private:
		VecMat srcCnls, rstCnls;
		HQRCdata::HKCAppItem* appitem;

	};
	class HQRCode
	{
	public:
		HQRCode(string srcImg, string usermap, string mask, string text, string result,int size = 1, bool color = false, int version = 5, int level = 3,  int us = -1, int bc = -1)
		{
			ColorVersion = color;
			uslevel = us;
			bclevel = bc;
			m_src = cv::imread(srcImg,-1);
			m_user = cv::imread(usermap,1);
			m_mask = cv::imread(mask,0);
			m_qrcparam = new HQRCdata::HKCQRCParam(text, version, static_cast<HQRCdata::HKEECL>(level));
			excute();
			cv::resize(m_result,m_result,cv::Size(m_result.cols*size,m_result.rows*size),0,0,INTER_NEAREST );
			imwrite(result,m_result);
			delete m_qrcparam;

		}
		HQRCode(string srcImg, string text, string result,int size = 1, bool color = false, int version = 5, int level = 3, int us = -1, int bc = -1)
		{
			ColorVersion = color;
			uslevel = us;
			bclevel = bc;
			m_src = cv::imread(srcImg,-1);
			m_qrcparam = new HQRCdata::HKCQRCParam(text, version, static_cast<HQRCdata::HKEECL>(level));
			excute();
			cv::resize(m_result,m_result,cv::Size(m_result.cols*size,m_result.rows*size),0,0,INTER_NEAREST );
			imwrite(result,m_result);
			delete m_qrcparam;

		}
		HQRCode(cv::Mat srcImg, cv::Mat usermap, cv::Mat mask, string text, cv::Mat& result,int size = 1, bool color = false, int version = 5, int level = 3, int us = -1, int bc = -1)
		{
			ColorVersion = color;
			uslevel = us;
			bclevel = bc;
			m_src = srcImg;
			m_user = usermap;
			m_mask = mask;
			m_qrcparam = new HQRCdata::HKCQRCParam(text, version, static_cast<HQRCdata::HKEECL>(level));
			excute();
			cv::resize(m_result,m_result,cv::Size(m_result.cols*size,m_result.rows*size),0,0,INTER_NEAREST );
			result = m_result.clone();
			delete m_qrcparam;

		}
		HQRCode(cv::Mat srcImg, string text, cv::Mat& result,int size = 1, bool color = false, int version = 5, int level = 3, int us = -1, int bc = -1)
		{
			ColorVersion = color;
			uslevel = us;
			bclevel = bc;
			m_src = srcImg;
			m_qrcparam = new HQRCdata::HKCQRCParam(text, version, static_cast<HQRCdata::HKEECL>(level));
			excute();
			cv::resize(m_result,m_result,cv::Size(m_result.cols*size,m_result.rows*size),0,0,INTER_NEAREST );
			result = m_result.clone();
			delete m_qrcparam;
		}
		void excute()
		{
			if (uslevel != -1 || bclevel != -1)
			{
				Mat inImg, mask;
				HKCV::Mat_Decompose(m_src, inImg, mask);
				if (uslevel >= 0 && uslevel<3)
				{
					HKCV::Unsharp_Mask(inImg, inImg, uslevel, mask);
					//cv::imshow("test0",inImg);
				}
				if (bclevel >= 0 && bclevel<3)
				{
					HKCV::Brightness_Contrast(inImg, inImg, bclevel);
					//cv::imshow("test1",inImg);
				}
				//waitKey(1);
				if (!mask.empty())
				{
					VecMat channels;
					channels.push_back(inImg);
					channels.push_back(mask);
					cv::merge(channels, m_src);
				}
				cv::imshow("test",m_src);
				waitKey(1);
			}

			if (!ColorVersion)
			{
				if (m_mask.empty())
				{
					HQRC(m_src, m_user, m_qrcparam, ori, halftone, m_result);
				}
				else
					HQRC(m_src, m_user, m_mask, m_qrcparam, ori, halftone, m_result);
			}
			else if (ColorVersion)
			{
				if (m_mask.empty())
				{
					CHQRC(m_src, m_user, m_qrcparam, ori, halftone, m_result);
				}
				else
					CHQRC(m_src, m_user, m_mask, m_qrcparam, ori, halftone, m_result);
			}
		}
	public:
		virtual ~HQRCode(void){}
	private:
		cv::Mat m_src;
		cv::Mat m_user;
		cv::Mat m_mask;
		cv::Mat ori;
		cv::Mat halftone;
		bool ColorVersion;
		cv::Mat m_result;
		int uslevel;
		int bclevel;
		HQRCdata::HKCQRCParam* m_qrcparam;
	};
}
namespace VHQRCode
{
	class VHQRC
	{
	public:

		VHQRC(vector<cv::Mat> srcImgs, vector<cv::Mat> masks, HQRCdata::HKCQRCParam* qrcparam, cv::Mat ORIQRC, vector<cv::Mat>& Halftone, vector<cv::Mat>& dstimg)
		{
			appitem = NULL;
			appitem = new HQRCdata::HKCAppItem;
			HQRCdata::HKCImgData& imagedata = appitem->Data()->ImgData;
			HQRCdata::HKCQRCData& qrcdata = appitem->Data()->QRCData;
			imagedata.SrcImgs = srcImgs;   // Read the file
			//imagedata.UserMap=usermap; // Read the file
			imagedata.Masks = masks;
			HQRCdata::HKCQRCParam* QRCparam = appitem->Param()->QRCode();
			QRCparam->m_Text = qrcparam->m_Text;
			QRCparam->m_Ver = qrcparam->m_Ver;
			QRCparam->m_ECL = qrcparam->m_ECL;

			vector<HQRCALGORITHM::HKCAlgorithm*>* algoObjs = new vector<HQRCALGORITHM::HKCAlgorithm*>;
			if (!appitem->Data()->PDBData.isReady)
				algoObjs->push_back(new HQRCALGORITHM::HKCPDBProc1);

			algoObjs->push_back(new HQRCALGORITHM::HKCQRCGen1);

			algoObjs->push_back(new HQRCALGORITHM::HKCDataInit1);

			algoObjs->push_back(new HQRCALGORITHM::HKCCannyFetr);

			algoObjs->push_back(new HQRCALGORITHM::HKCFetrImp);

			algoObjs->push_back(new HQRCALGORITHM::HKCSAEDHftn);

			//algoObjs->Add(new HQRCALGORITHM::HKCUGCOptmzr);
			algoObjs->push_back(new HQRCALGORITHM::HKCNNOptmzr);

			//algoObjs->Add(new HQRCALGORITHM::HKCDefComposr);

			for (int i = 0; algoObjs->size()>0; i++)
			{
				//cout<<MarshalString(algoObj->ToString())<<endl;
				if (!algoObjs->front()->Execute(appitem))
				{
					cout << "failed!" << endl;
					break;
				}
				algoObjs->erase(algoObjs->begin());
			}

			dstimg = imagedata.RstImgs;
			Halftone = imagedata.HalftoneImgs;
			ORIQRC = qrcdata.QRCImg;
			cout << "finish!" << endl;

		}

		VHQRC(vector<cv::Mat> srcImgs, HQRCdata::HKCQRCParam* qrcparam, cv::Mat& ORIQRC, cv::Mat& Halftone, cv::Mat& dstimg)
		{
			appitem = NULL;
			appitem = new HQRCdata::HKCAppItem;
			HQRCdata::HKCImgData& imagedata = appitem->Data()->ImgData;
			HQRCdata::HKCQRCData& qrcdata = appitem->Data()->QRCData;
			imagedata.SrcImgs = srcImgs;   // Read the file
			//imagedata.UserMap=usermap; // Read the file
			HQRCdata::HKCQRCParam* QRCparam = appitem->Param()->QRCode();
			QRCparam->m_Text = qrcparam->m_Text;
			QRCparam->m_Ver = qrcparam->m_Ver;
			QRCparam->m_ECL = qrcparam->m_ECL;

			vector<HQRCALGORITHM::HKCAlgorithm*>* algoObjs = new vector<HQRCALGORITHM::HKCAlgorithm*>;
			if (!appitem->Data()->PDBData.isReady)
				algoObjs->push_back(new HQRCALGORITHM::HKCPDBProc1);

			algoObjs->push_back(new HQRCALGORITHM::HKCQRCGen1);

			algoObjs->push_back(new HQRCALGORITHM::HKCDataInit1);

			algoObjs->push_back(new HQRCALGORITHM::HKCCannyFetr);

			algoObjs->push_back(new HQRCALGORITHM::HKCFetrImp);

			algoObjs->push_back(new HQRCALGORITHM::HKCSAEDHftn);

			//algoObjs->Add(new HQRCALGORITHM::HKCUGCOptmzr);
			algoObjs->push_back(new HQRCALGORITHM::HKCNNOptmzr);

			//algoObjs->Add(new HQRCALGORITHM::HKCDefComposr);

			for (int i = 0; i <algoObjs->size(); i++)
			{

				//cout<<MarshalString(algoObj->ToString())<<endl;
				if (!algoObjs->front()->Execute(appitem))
				{
					cout << "failed" << endl;
					break;
				}
				algoObjs->erase(algoObjs->begin());
			}
			dstimg = imagedata.RstImg;
			Halftone = imagedata.HalftoneImg;
			ORIQRC = qrcdata.QRCImg;
			cout << "finish!" << endl;
		}


	public:
		virtual ~VHQRC(void){}

	private:

		HQRCdata::HKCAppItem* appitem;

	};
}
